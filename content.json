{"meta":{"title":"PeHaZ.OvO","subtitle":null,"description":null,"author":"PeHaZ","url":"http://www.peihan.cc","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-05-02T15:41:36.281Z","updated":"2019-05-02T15:41:36.281Z","comments":true,"path":"404.html","permalink":"http://www.peihan.cc/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2019-05-02T15:37:02.923Z","updated":"2019-05-02T15:37:02.923Z","comments":true,"path":"categories/index.html","permalink":"http://www.peihan.cc/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-05-02T16:41:00.820Z","updated":"2019-05-02T16:41:00.820Z","comments":true,"path":"friends/index.html","permalink":"http://www.peihan.cc/friends/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-05-02T17:24:07.282Z","updated":"2019-05-02T17:24:07.282Z","comments":true,"path":"about/index.html","permalink":"http://www.peihan.cc/about/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 刚毕业小码农一枚，Working In Alibaba……"},{"title":"所有标签","date":"2019-05-02T15:40:19.591Z","updated":"2019-05-02T15:40:19.591Z","comments":true,"path":"tags/index.html","permalink":"http://www.peihan.cc/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-05-02T15:59:19.274Z","updated":"2019-05-02T15:59:19.274Z","comments":true,"path":"projects/index.html","permalink":"http://www.peihan.cc/projects/index.html","excerpt":"","text":""}],"posts":[{"title":"【RabbitMQ系列二】初识rabbitmq","slug":"article/2018/【RabbitMQ系列二】初识rabbitmq","date":"2018-10-14T06:30:27.000Z","updated":"2019-05-03T06:58:04.206Z","comments":true,"path":"2018/10/14/article/2018/【RabbitMQ系列二】初识rabbitmq/","link":"","permalink":"http://www.peihan.cc/2018/10/14/article/2018/【RabbitMQ系列二】初识rabbitmq/","excerpt":"1 rabbitmq用户管理rabbitmq默认安装完只有guest一个用户，这个用户默认只能使用loalhost进行访问，我们如果想在自己的应用中使用mq需要创建新的用户，该小节主要描述rabbitmq的用户管理。","text":"1 rabbitmq用户管理rabbitmq默认安装完只有guest一个用户，这个用户默认只能使用loalhost进行访问，我们如果想在自己的应用中使用mq需要创建新的用户，该小节主要描述rabbitmq的用户管理。 1.1 用户管理 新增用户 1rabbitmqctl add_user [username] [password] 查看所有用户 1rabbitmqctl list_users 删除用户 1rabbitmqctl delete_user [username] 修改用户密码 1rabbitmqctl change_password [username] [newpassword] 1.2 角色管理rabbitmq的角色一共有五种，权限从高到低分别为：administrator、monitoring、policymaker、management、[other] administrator可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。 monitoring可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等) policymaker可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。 management仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。 other无法登陆管理控制台，通常就是普通的生产者和消费者。 1.2.1 操作角色 设置用户角色 1rabbitmqctl set_user_tags [user] [Tag] 1.3 权限管理权限管理是设置用户对exchange和queen等的操作权限。 设置权限 1rabbitmqctl set_permissions -p / root \".*\" \".*\" \".*\" 查看具体用户权限 1rabbitmqctl list_user_permissions [user] 查看具体path权限 1rabbitmqctl list_permissions -p / 清除用户权限 1rabbitmqctl clear_permissions [-p VHostPath] [user] 2 Hello World这里我们演示rabbitmq的hello world级别的demo,一方面可以验证rabbitmq的安装以及配置是否正确，另一方面也可以对rabbitmq整体有个把握。 producer这里生态者向rabbitmq发送一端hello world文本。代码如下： 1234567891011121314151617181920212223242526272829303132333435package cc.peihan.polaris.middleware.rabbitmq.first;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import com.rabbitmq.client.MessageProperties;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Producer &#123; public static final String EXCHARGE_NAME = \"exchage_demo\"; public static final String ROUTING_KEY = \"routingkey_demo\"; public static final String QUEEN_NAME = \"queen_demo\"; public static final String IP = \"127.0.0.1\"; public static final int PORT = 5672; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(IP); connectionFactory.setPort(PORT); connectionFactory.setUsername(\"root\"); connectionFactory.setPassword(\"root\"); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); channel.exchangeDeclare(EXCHARGE_NAME, \"direct\", true, false, null); channel.queueDeclare(QUEEN_NAME, true, false, false, null); channel.queueBind(QUEEN_NAME, EXCHARGE_NAME, ROUTING_KEY); String message = \"Hello World!\"; channel.basicPublish(EXCHARGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes()); channel.close(); connection.close(); &#125;&#125; 运行之后我们可以观察rabbitmq的监控面板，队列中已经有一条消息等待消费了。 消费者消费者代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243package cc.peihan.polaris.middleware.rabbitmq.first;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;public class Consumer &#123; public static final String QUEEN_NAME = \"queen_demo\"; public static final String IP = \"127.0.0.1\"; public static final int PORT = 5672; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123; Address[] addresses = new Address[]&#123; new Address(IP, PORT) &#125;; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setUsername(\"root\"); connectionFactory.setPassword(\"root\"); Connection connection = connectionFactory.newConnection(addresses); Channel channel = connection.createChannel(); channel.basicQos(64); com.rabbitmq.client.Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"recv message: \" + new String(body)); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; channel.basicConsume(QUEEN_NAME, consumer); TimeUnit.SECONDS.sleep(5); channel.close(); connection.close(); &#125;&#125; 运行之后再观察监控面板，消息已经被消费掉了： 3 总结本小节是对rabbit入门的开始，介绍了rabbit的用户管理以及hello world演示。 参考：《rabbitmq实战指南》 中国工信出版社《rabbitmq用户管理》https://my.oschina.net/hncscwc/blog/262246","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.peihan.cc/categories/中间件/"}],"tags":[]},{"title":"SQLAlchemy学习笔记","slug":"article/2018/SQLAlchemy学习笔记","date":"2018-09-16T08:10:04.000Z","updated":"2019-05-03T06:57:23.752Z","comments":true,"path":"2018/09/16/article/2018/SQLAlchemy学习笔记/","link":"","permalink":"http://www.peihan.cc/2018/09/16/article/2018/SQLAlchemy学习笔记/","excerpt":"SQLAlchemy学习笔记0 背景SQLAlchemy是python的一个数据库ORM工具，可以让我们很方便的来操作数据库，既可以使用简单的sql语句来操作db,也可以使用类似于hibernate的ORM模式，满足我们的各种开发需求，本篇文章主要说明关于SQLAlchemy的使用相关。 官方地址： http://www.sqlalchemy.org/","text":"SQLAlchemy学习笔记0 背景SQLAlchemy是python的一个数据库ORM工具，可以让我们很方便的来操作数据库，既可以使用简单的sql语句来操作db,也可以使用类似于hibernate的ORM模式，满足我们的各种开发需求，本篇文章主要说明关于SQLAlchemy的使用相关。 官方地址： http://www.sqlalchemy.org/ 1 准备工作 安装\bSQLAlchemy 1pip install SQLAlchemy 安装mysql驱动 如果仅仅是安装SQLAlchemy还是不能直接用的，需要有mysql的python连接驱动，类比于hibernate和JDBC的关系。 python的mysql驱动有好几个，我们这里顺手分析一下。 MySQLdb这是最远古的mysql驱动，使用c语言编写，已经在github很久没有更新了，不建议使用。如果在SQLAlchemy中没有指定使用的驱动的话，默认就是使用此驱动。 PyMySQLpymsql是一个纯python编写的mysql驱动，可以用于python2.7和py3+，使用比较广泛，建议使用。搭配SQLAlchemy时需要使用mysql+pymysql来指定使用pymysql驱动 1pip install PyMySQL mysql-connector-pythonmysql-connector-python是mysql官方出的纯python的mysql驱动，支持py2和py3，建议使用。搭配SQLArchemy使用时需要使用mysql+mysqlconnector来指定使用的\b驱动。 1pip install mysql-connector-python 我这里选择使用pymsql 准备一张表 12345678910111213141516171819create table user ( id bigint not null auto_increment comment 'id', name varchar(128) not null default '' comment '姓名', age int not null default 0 comment '年龄', birthday timestamp not null comment '审核时间', created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', primary key (`id`), KEY `ix_created_at` (`created_at`), KEY `ix_updated_at` (`updated_at`))ENGINE = InnoDB DEFAULT CHARSET = utf8 COMMENT = '用户信息表' 预插入两条数据如图所示 2 不使用ORM模式SQLArchemy可以支持使用传统的模式来操作数据库。db连接串格式：1mysql+pymysql://root:root@localhost:3306/test 查询 123456789101112131415from config.db_config import testfrom sqlalchemy import create_enginefrom config.env_config import env# 创建engine连接engine = create_engine(test[env], echo=True)sql = \"select * from user\"with engine.connect() as con: rs = con.execute(sql) # 获取3条数据 fetchone() 获取一条数据 data = rs.fetchmany(3) print type(data) print data[0][1] 另一种查询写法，用for r in rs的迭代，比上一种性能要好，不用一直保持连接 1234567891011121314from config.db_config import testfrom sqlalchemy import create_enginefrom config.env_config import envengine = create_engine(test[env], echo=True)sql = \"select * from user\"with engine.connect() as con: rs = con.execute(sql) for r in rs: print type(r) print r.id print r.name 更新 删除 创建C U D 可以通过占位符的方式来更优雅的实现 123456789101112131415# -*- coding:utf-8 -*-import timefrom config.db_config import testfrom sqlalchemy import create_enginefrom config.env_config import envfrom sqlalchemy.sql import textengine = create_engine(test[env], echo=True)sql1 = \"select * from user\"sql2 = \"insert into user(name, age, birthday) values(:name, :age, :birthday)\"with engine.connect() as con: rs = con.execute(text(sql2), name='小王', age=34, birthday=time.strftime(\"2017-09-23\")) 事务 123456789with engine.connect() as con: trans = con.begin() try: r1 = con.execute(sql1) r2 = con.execute(text(sql2), name='小啦啦', age=34, birthday=time.strftime(\"2017-09-25\")) trans.commit() except: trans.rollback() raise 使用session来操作数据库 查询1234567891011121314151617import timefrom config.db_config import testfrom sqlalchemy import create_enginefrom config.env_config import envfrom sqlalchemy.sql import textfrom sqlalchemy.orm import sessionmakersql1 = \"select * from user\"sql2 = \"insert into user(name, age, birthday) values(:name, :age, :birthday)\"engine = create_engine(test[env], echo=True)user_session = sessionmaker(bind=engine)session = user_session()rs = session.execute(sql1)for r in rs: print type(r) print r.name 更新 删除 插入 12345678910111213141516import timefrom config.db_config import testfrom sqlalchemy import create_enginefrom config.env_config import envfrom sqlalchemy.sql import textfrom sqlalchemy.orm import sessionmakersql1 = \"select * from user\"sql2 = \"insert into user(name, age, birthday) values(:name, :age, :birthday)\"engine = create_engine(test[env], echo=True)user_session = sessionmaker(bind=engine)session = user_session()session.execute(sql2, &#123;\"name\": \"小虎虎\", \"age\": 12, \"birthday\": time.strftime(\"2017-09-25\")&#125;)session.commit() 注意： 使用session时，更新操作必须手动commit 使用ORM模式SQLAlchemy的最大亮点在于ORM模式，我们接下来来说明在ORM模式下如何操作数据库。 开始之前，我们都知道在ORM模式下，我们需要有个model来与数据库中的表对应，我们这里不需要手动来写model，python有工具可以自动生成model。 安装sqlacodegen 1pip install sqlacodegen sqlacodegen用我们配置的db连接串就可以来生成整个db里的model类，每个表对应一个model类 1sqlacodegen mysql+pymysql://root:root@localhost:3306/test &gt; models.py 生成的内容如下： 123456789101112131415161718# coding: utf-8from sqlalchemy import Column, Date, String, TIMESTAMP, textfrom sqlalchemy.dialects.mysql import BIGINT, INTEGERfrom sqlalchemy.ext.declarative import declarative_baseBase = declarative_base()metadata = Base.metadataclass User(Base): __tablename__ = 'user' id = Column(BIGINT(20), primary_key=True) name = Column(String(128), nullable=False, server_default=text(\"''\")) age = Column(INTEGER(11), nullable=False, server_default=text(\"'0'\")) birthday = Column(TIMESTAMP, nullable=False, server_default=text(\"CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\")) created_at = Column(TIMESTAMP, nullable=False, index=True, server_default=text(\"CURRENT_TIMESTAMP\")) updated_at = Column(TIMESTAMP, nullable=False, index=True, server_default=text(\"CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\")) 我个人不喜欢将很多的逻辑放在db层来做，所以我们接下来只会展示简单的查询与更新，复杂查询建议在应用层进行，提高数据库的并发，不要将压力都集中到db层 以下的小例子都是比较常用的用法，日用应该足够了…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102# -*- coding:utf-8 -*-import timefrom config.db_config import testfrom sqlalchemy import create_engine, desc, distinctfrom config.env_config import envfrom sqlalchemy.sql import textfrom sqlalchemy.orm import sessionmakerfrom model.models import Userengine = create_engine(test[env], echo=True)user_session = sessionmaker(bind=engine)session = user_session()time = time.strftime(\"2017-09-25\")# 查询单条数据 first()qUser = session.query(User) \\ .filter(User.id == 1) \\ .first()print type(qUser)print qUser.id# 多个查询条件查询多条数据qUsers = session.query(User) \\ .filter(User.id &lt; 20) \\ .filter(User.name == \"小火火\") \\ .order_by(desc(User.id)) \\ .all()print type(qUsers)print qUsersfor user in qUsers: print user.id# 添加数据user = User(name=\"小火火\", age=345, birthday=time)session.add(user)session.commit()print user.id# 修改数据# merge方法会判断主键，如果存在则更新，不存在则新建user.name = \"小水水\"session.merge(user)session.commit()# merge 新建user2 = User(name=\"小土土\", age=456, birthday=time)session.merge(user2)session.commit()# 另外一种更新方法，记得commituser3 = session.query(User) \\ .filter(User.id == 1) \\ .update(&#123;\"name\": \"小兔兔兔兔图图图\"&#125;)session.commit()# 删除 生产环境不建议物理删除，可以使用逻辑删除，is_valid字段为0session.query(User) \\ .filter(User.id == 2) \\ .delete()session.commit()# 根据主键id单个查询数据user4 = session.query(User).get(3)print user4.id# 返回结果集的index为 1 - 9users5 = session.query(User)[1:10]for user in users5: print user.id# 分页查询 实际查询数据时 不建议一下查询大量数据，尽量使用分页查询来减小db的压力users6 = session.query(User) \\ .offset(5) \\ .limit(10) \\ .all()for user in users6: print user.id# 只查询部分属性 注意在这种模式下查出来的对象的类型不是model的类型，而是sqlalchemy.util._collections.result 而且只有查询的字段才有值，users7 = session.query(User.name) \\ .limit(5) \\ .all()print type(users7)for user in users7: print type(user) print user.name# 去重查询users8 = session.query(distinct(User.name).label(\"name\")) \\ .all()print type(users8)for user in users8: print user.name 总结SQLAlchemy是python里比较好用的ORM框架，相信各位同学看了本文后对于SQLAlchemy应该算是入门，进阶请详细阅读官方文档说明。","categories":[{"name":"python","slug":"python","permalink":"http://www.peihan.cc/categories/python/"}],"tags":[]},{"title":"【一起玩Netty（二）】动手用Netty实现HTTP Server","slug":"article/2018/【一起玩Netty（二）】动手用Netty实现HTTP-Server","date":"2018-08-07T05:35:36.000Z","updated":"2019-05-03T07:00:12.543Z","comments":true,"path":"2018/08/07/article/2018/【一起玩Netty（二）】动手用Netty实现HTTP-Server/","link":"","permalink":"http://www.peihan.cc/2018/08/07/article/2018/【一起玩Netty（二）】动手用Netty实现HTTP-Server/","excerpt":"0 背景1 V1版本用Netty来实现自己的HTTP Server是很容易的，Netty已经为我们提供了\b很多的工具类，编解码类，我们要做的就是将Netty为我们提供的ChannelHandler类加入ChannelPipeline。我们要做的是如何从零来构建我们的HTTP Server，然后一步一步发现问题，并去完善。我们刚开始只选用HttpServerCodec这个server端的编码和解码Handler。HttpServerCodec相当于HttpRequestDecoder和HttpResponseEncoder。然后再添加一个自定义的Handler-HttpHandler。","text":"0 背景1 V1版本用Netty来实现自己的HTTP Server是很容易的，Netty已经为我们提供了\b很多的工具类，编解码类，我们要做的就是将Netty为我们提供的ChannelHandler类加入ChannelPipeline。我们要做的是如何从零来构建我们的HTTP Server，然后一步一步发现问题，并去完善。我们刚开始只选用HttpServerCodec这个server端的编码和解码Handler。HttpServerCodec相当于HttpRequestDecoder和HttpResponseEncoder。然后再添加一个自定义的Handler-HttpHandler。 1.1 HttpServerInitializer第一步我们先来实现我们的初始化类，为了代码更容易维护，我们没有选择使用匿名类而选择实现一个具名类。人狠话不多，直接看代码： 1234567891011public class HttpServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) &#123; ChannelPipeline channelPipeline = ch.pipeline(); //集合了编码器和解码器 channelPipeline.addLast(new HttpServerCodec()); //自定义处理器 channelPipeline.addLast(new HttpHandler()); &#125;&#125; 1.2 HttpServer 启动类第二步我们需要来编写一个启动类，来引导我们的Server启动。V1版本只是一个原型版本，我们对于异常处理不做要求，所以代码里可能对异常处理的不够完美，没事，我们慢慢来。 123456789101112131415161718192021222324252627282930public class HttpServer &#123; private final int port; public HttpServer(int port) &#123; this.port = port; &#125; //启动server public void start() &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.option(ChannelOption.SO_BACKLOG, 1024); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new HttpServerInitializer()); Channel ch = b.bind(port).sync().channel(); ch.closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 1.3 HttpHandler 自定义处理类最后一步，我们只需要编写自己的处理类，就可以大功告成了。再编写代码之前，我们先来看点理论知识。在Netty中，一个完整的http请求如下图所示：所以在我们不采取特殊处理的时候，我们的Handler可能会多次触发，进行多次处理。我们来验证下。 v1版本我们不采取任何特殊处理，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class HttpHandler extends SimpleChannelInboundHandler&lt;Object&gt; &#123; private static final Logger logger = LoggerFactory.getLogger(HttpHandler.class); private static final byte[] CONTENT = &#123;'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'&#125;; private boolean keepAlive; @Override protected void channelRead0(ChannelHandlerContext ctx, Object msg) &#123; logger.info(\"class:&#123;&#125;\", msg.getClass().getName()); if (msg instanceof HttpRequest) &#123; HttpRequest request = (HttpRequest) msg; if (request.method() != HttpMethod.GET) &#123; throw new IllegalStateException(\"请求不是GET请求.\"); &#125; if (HttpUtil.is100ContinueExpected(request)) &#123; ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE)); &#125; keepAlive = HttpUtil.isKeepAlive(request); &#125; if (msg instanceof LastHttpContent) &#123; FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, Unpooled.wrappedBuffer(CONTENT)); response.headers().set(CONTENT_TYPE, \"text/plain\"); response.headers().set(CONTENT_LENGTH, response.content().readableBytes()); if (!keepAlive) &#123; ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); &#125; else &#123; response.headers().set(CONNECTION, HttpHeaders.Values.KEEP_ALIVE); ctx.writeAndFlush(response); &#125; &#125; &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) &#123; logger.info(\"channelReadComplete\"); ctx.flush(); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; logger.info(\"exceptionCaught\"); if (cause != null) &#123; cause.printStackTrace(); &#125; if (ctx != null) &#123; ctx.close(); &#125; &#125;&#125; 1.4 UnitTest我们接下来启动服务观察”class:{}”这行日志的打印次数。我们这里选择来写一个test来测试下。 12345@org.junit.Testpublic void testHttpServer() &#123; HttpServer httpServer = new HttpServer(8888); httpServer.start();&#125; 使用postman发送一个最简单的get请求，日志输出如下：12323:31:04.259 [nioEventLoopGroup-3-1] INFO c.p.p.netty.http.v1.HttpHandler - class:io.netty.handler.codec.http.DefaultHttpRequest23:31:04.650 [nioEventLoopGroup-3-1] INFO c.p.p.netty.http.v1.HttpHandler - class:io.netty.handler.codec.http.LastHttpContent$123:31:05.201 [nioEventLoopGroup-3-1] INFO c.p.p.netty.http.v1.HttpHandler - channelReadComplete 我们可以很直观的看到class:{}这行日志一共输出了两次，说明请求两次经过我们的Handler，两次之后输出了channelReadComplete的日志，然后客户端postman收到了我们发回的HelloWorld字符串。从这里，我们可以得出结论，http请求在netty中是被切割成多个部分进行传输的，这样对于我们的逻辑处理特别的不方便，我们将在V2版本里解决这个问题。 2 V2版本这个版本我们来解决V1版本问题。我们首先为HttpServerInitializer增加一个消息聚合器，现在代码如下：12345678910111213public class HttpServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) &#123; ChannelPipeline channelPipeline = ch.pipeline(); //集合了编码器和解码器 channelPipeline.addLast(new HttpServerCodec()); //消息聚合器 channelPipeline.addLast(new HttpObjectAggregator(1024 * 1024)); //自定义处理器 channelPipeline.addLast(new HttpHandler()); &#125;&#125; 然后修改HttpHandler的代码如图所示：12345678910111213141516171819202122232425262728293031323334353637public class HttpHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt; &#123; private static final Logger logger = LoggerFactory.getLogger(HttpHandler.class); private static final byte[] CONTENT = &#123;'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'&#125;; @Override protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest msg) &#123; logger.info(\"class:&#123;&#125;\", msg.getClass().getName()); boolean keepAlive = HttpUtil.isKeepAlive(msg); FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, Unpooled.wrappedBuffer(CONTENT)); response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain\"); response.headers().setInt(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes()); if (!keepAlive) &#123; ctx.write(response).addListener(ChannelFutureListener.CLOSE); &#125; else &#123; response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE); ctx.write(response); &#125; &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) &#123; logger.info(\"channelReadComplete\"); ctx.flush(); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; logger.info(\"exceptionCaught\"); if (cause != null) &#123; cause.printStackTrace(); &#125; if (ctx != null) &#123; ctx.close(); &#125; &#125;&#125; 我们在此处修改了泛型类型，有了消息聚合器后，我们只需要接受FullHttpRequest及其子类就可以了。 我们重新运行下，目前的日志输出如下：1200:09:10.968 [nioEventLoopGroup-3-1] INFO c.p.p.netty.http.v2.HttpHandler - class:io.netty.handler.codec.http.HttpObjectAggregator$AggregatedFullHttpRequest00:09:47.383 [nioEventLoopGroup-3-1] INFO c.p.p.netty.http.v2.HttpHandler - channelReadComplete 此时我们可以看到日志”class:{}”只输出了一次，说明请求只经过了一次我们的Handler。而且我们通过调试可以观察到当执行了channelReadComplete中的ctx.flush()后我们的客户端才能获得response。 3 小结至此我们已经实现了简单的HTTP Server，下一步我们将在此基础上实现我们自己的HTTP开发框架。","categories":[{"name":"Netty","slug":"Netty","permalink":"http://www.peihan.cc/categories/Netty/"}],"tags":[]},{"title":"【瞎扯设计模式】责任链模式","slug":"article/2018/【瞎扯设计模式】责任链模式","date":"2018-08-05T06:52:15.000Z","updated":"2019-05-03T07:00:24.329Z","comments":true,"path":"2018/08/05/article/2018/【瞎扯设计模式】责任链模式/","link":"","permalink":"http://www.peihan.cc/2018/08/05/article/2018/【瞎扯设计模式】责任链模式/","excerpt":"#【瞎扯设计模式】责任链模式 0 背景最近在看Netty，发现Netty中的ChannelPipeline和ChannelHandler是责任链模式的很好的应用。本文是对责任链模式的分析以及一个小例子来说明责任链模式。 1 常用场景责任链模式常见应用场景为需要进行流式操作的场景。比如，审核流。常见场景为发起人发起采购申请，Director可以审核&lt;5000的采购单，VicePresident可以审核&lt;100000的采购单，President可以审核&lt;1000000的采购单。即整个处理过程可能会经过很多个不同的处理个体，在这种情况下，比较适合使用责任链模式。","text":"#【瞎扯设计模式】责任链模式 0 背景最近在看Netty，发现Netty中的ChannelPipeline和ChannelHandler是责任链模式的很好的应用。本文是对责任链模式的分析以及一个小例子来说明责任链模式。 1 常用场景责任链模式常见应用场景为需要进行流式操作的场景。比如，审核流。常见场景为发起人发起采购申请，Director可以审核&lt;5000的采购单，VicePresident可以审核&lt;100000的采购单，President可以审核&lt;1000000的采购单。即整个处理过程可能会经过很多个不同的处理个体，在这种情况下，比较适合使用责任链模式。 2 为什么为什么要使用责任链模式，要回答这个问题我们先来看看，不使用责任链模式应该怎样描述这个过程。不使用设计模式我们倾向于在一个处理类中来来处理前文提到的过程。大致代码如下： 123456789101112131415161718192021222324252627public class PurchaseRequestHandler &#123; public void handlePurchaseRequest(PurchaseRequest purchaseRequest) &#123; if (purchaseRequest == null) &#123; return; &#125; if (purchaseRequest.getAmount() &lt; 5000) &#123; handleByDirector(purchaseRequest); &#125; else if (purchaseRequest.getAmount() &lt; 100000) &#123; handleByVicePresident(purchaseRequest); &#125; else if (purchaseRequest.getAmount() &lt; 1000000) &#123; handleByPresident(purchaseRequest); &#125; &#125; public void handleByDirector(PurchaseRequest request) &#123; //具体逻辑省略 &#125; public void handleByVicePresident(PurchaseRequest request) &#123; //具体逻辑省略 &#125; public void handleByPresident(PurchaseRequest request) &#123; //具体逻辑省略 &#125;&#125; 以上代码即为不使用设计模式时的大概写法，在逻辑比较简单时，这种写法没有什么问题，当代码逻辑变的很复杂时，这种写法就会暴露很多问题。 PurchaseRequestHandler这个类包含了整个的处理逻辑，当逻辑变得复杂时，这个类会变得过于复杂，不利于维护 目前审核顺序为Director -&gt; VP -&gt; President，当我们需要调整审核顺序或者增加审核职位时候，必须调整整个类的源码 这种写法审核流程顺序完全由PurchaseRequestHandler控制，调用方无法进行定制，牺牲了扩展性和灵活性 3 应该怎么做我个人很不喜欢谈设计模式上来直接先来一张UML图，很多时候我们对一种设计模式还不熟悉的时候，一张UML图会让我们更加的一头雾水。我们先来思考一下如何解决上面提到的问题。为了解决问题1，我们首先可以拆解这个类，将每一个审核人都拆解为一个单独的类，这样的话，我们只需要单独的维护每一个职位。这样，我们可以拆解为Director、VicePresident、President三个类。其实问题2和问题3的核心问题在于一点 ，我们如何将审核流的控制权从处理类中抽离出来，由调用方来决定具体的审核顺序。既然要调用方来决定审核顺序，那么必须有对应的方法或者途径让调用方来设置审核顺序，既审核链路。我们很自然的可以想到可以让每一个类都持有一个对更高一级审核人的引用。这样可以让调用方自由的组装审核链路，实现这一想法很简单，我们在上一步的三个类的基础上实现一个抽象类Approer，这个类中有processRequest方法来处理对应的请求，同时持有一个Approer对象的引用，用来将请求传递给下一级。这样Director、VicePresident、President这三个类分别继承Approer就可以了。调用方可以调用set方法来自定义自己的审核顺序。 4 代码实现根据上一节的叙述，我们首先来实现Approer,代码如下：1234567891011121314151617181920212223242526@Data@NoArgsConstructorpublic abstract class Approer &#123; /** * 后继对象 */ private Approer successor; private String name; public static final String template = \"%s:%s审核了采购单:%s 金额:%s 目的:%s\"; public Approer(String name) &#123; this.name = name; &#125; /** * 处理请求 * @param purchaseRequest */ public abstract void(PurchaseRequest purchaseRequest);&#125; Director、VicePresident、President这三个类分别继承Approer，并实现自己的处理逻辑。 Director123456789101112131415public class Director extends Approer &#123; public Director(String name) &#123; super(name); &#125; @Override public void processRequest(PurchaseRequest purchaseRequest) &#123; if (purchaseRequest.getAmount() &lt; 5000) &#123; System.out.println(String.format(template, \"Director\", this.getName(), purchaseRequest.getId(), purchaseRequest.getAmount(), purchaseRequest.getPurpose())); &#125; else &#123; this.getSuccessor().processRequest(purchaseRequest); &#125; &#125;&#125; VicePresident123456789101112131415public class VicePresident extends Approer &#123; public VicePresident(String name) &#123; super(name); &#125; @Override public void processRequest(PurchaseRequest purchaseRequest) &#123; if (purchaseRequest.getAmount() &lt; 100000) &#123; System.out.println(String.format(template, \"VP\", this.getName(), purchaseRequest.getId(), purchaseRequest.getAmount(), purchaseRequest.getPurpose())); &#125; else &#123; this.getSuccessor().processRequest(purchaseRequest); &#125; &#125;&#125; 123456789101112131415public class President extends Approer &#123; public President(String name) &#123; super(name); &#125; @Override public void processRequest(PurchaseRequest purchaseRequest) &#123; if (purchaseRequest.getAmount() &lt; 1000000) &#123; System.out.println(String.format(template, \"President\", this.getName(), purchaseRequest.getId(), purchaseRequest.getAmount(), purchaseRequest.getPurpose())); &#125; else &#123; this.getSuccessor().processRequest(purchaseRequest); &#125; &#125;&#125; 接下来我们再来编写调用方的代码：1234567891011121314151617public static void main(String[] args) &#123; Approer a = new Director(\"a\"); Approer b = new VicePresident(\"b\"); Approer c = new President(\"c\"); a.setSuccessor(b); b.setSuccessor(c); PurchaseRequest pr1 = new PurchaseRequest(1, 4000, \"购买倚天剑\"); PurchaseRequest pr2 = new PurchaseRequest(2, 60000, \"购买《葵花宝典》\"); PurchaseRequest pr3 = new PurchaseRequest(3, 800000, \"购买桃花岛\"); a.processRequest(pr1); a.processRequest(pr2); a.processRequest(pr3);&#125; 运行结果： 123Director:a审核了采购单:1 金额:4000.0 目的:购买倚天剑VP:b审核了采购单:2 金额:60000.0 目的:购买《葵花宝典》President:c审核了采购单:3 金额:800000.0 目的:购买桃花岛 5 总结理解了代码实现之后，这时候我们可以来看看UML图是如何描述责任链模式的。 在责任链模式里，很多对象由每一个对象对其下一级的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的调用方并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响调用方的情况下动态地重新组织链和分配责任。 6 参考资料https://legacy.gitbook.com/book/quanke/design-pattern-java/details","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.peihan.cc/categories/设计模式/"}],"tags":[]},{"title":"30分钟入门flex布局","slug":"article/2018/30分钟入门flex布局","date":"2018-07-29T13:30:50.000Z","updated":"2019-05-03T07:01:05.951Z","comments":true,"path":"2018/07/29/article/2018/30分钟入门flex布局/","link":"","permalink":"http://www.peihan.cc/2018/07/29/article/2018/30分钟入门flex布局/","excerpt":"0 前言flex布局是目前比较流行的一种布局，对以前的box布局带来了很大的改进。如果你想优雅的进行页面布局，并且没有浏览器历史包袱，那么flex布局是一个很好的选择。本篇文章以一个小例子来说明flex布局。","text":"0 前言flex布局是目前比较流行的一种布局，对以前的box布局带来了很大的改进。如果你想优雅的进行页面布局，并且没有浏览器历史包袱，那么flex布局是一个很好的选择。本篇文章以一个小例子来说明flex布局。 1 基本模板我们以一个魔方的面来说明flex布局。首先我们来写最基本的HTML模板。 模板效果： 完整HTML: 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;flex demo&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; margin: 0px; padding: 0px; &#125; .box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; &#125; .item &#123; height: 100px; width: 100px; background-color: lightblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 下面我们为了节省篇幅，只写关键的css。 2 一个方块2.1 左对齐 css:1234567.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex; //只需这一行&#125; 2.2 居中对齐 css:12345678.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex; justify-content: center; //设定主轴居中对齐&#125; 2.3 居右对齐 css:12345678.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex; justify-content: flex-end; //居右对齐&#125; 2.4 4号位置 css:12345678.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex; align-items: center; //设定交叉轴的对齐方式 居中&#125; 2.5 整体居中 css:12345678910.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex; justify-content: center; align-items: center; /*主轴、交叉轴全部设定居中*/&#125; 2.6 6号位置 css:12345678910.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex; justify-content: flex-end; align-items: center; /*主轴居右，交叉轴居中*/&#125; 2.7 7号位置 css:12345678910.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex; justify-content: flex-start; align-items: flex-end; /*主轴居左，交叉轴居下*/&#125; 2.8 8号位置 css:12345678910.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex; justify-content: center; align-items: flex-end; /*主轴居中，交叉轴居下*/&#125; 2.9 9号位置css:12345678910.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex; justify-content: flex-end; align-items: flex-end; /*主轴居右，交叉轴居下*/&#125; 3 两个方块\b增加一个方块，我们需要再增加一个div元素，为了使方块间看的更加的清楚，我们给方块增加一个边框 3.1 1 3 位置css:123456789.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex; justify-content: space-between; /*等间距分割*/&#125; 3.2 1 7 位置css:123456789.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex; flex-direction: column; /*将主轴方向改为y方向*/ justify-content: space-between;&#125; 3.3 2 8 位置css:123456789.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; flex-direction: column; justify-content: space-between; align-items: center; /*交叉轴居中*/&#125; 3.3 3 9 位置css:123456789.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; flex-direction: column; justify-content: space-between; align-items: flex-end; /*交叉轴居右*/&#125; 3.4 1 5 位置 css:123456789101112.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex;&#125;.item:nth-child(2) &#123; align-self: center; /*使用子类选择器改变子元素的交叉轴对齐方式*/&#125; 3.5 1 9 位置 css:12345678910111213.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex; justify-content: space-between&#125;.item:nth-child(2) &#123; align-self: flex-end; /*使用子类选择器改变子元素的交叉轴对齐方式*/&#125; 4 三个方块在上一步的基础上\b再增加一个方块元素 4.1 1 5 9 位置 css:1234567891011121314151617.box &#123; margin: 50px auto; height: 300px; width: 300px; border: 4px solid red; display: flex; justify-content: space-between&#125;.item:nth-child(2) &#123; align-self: center; /*使用子类选择器改变子元素的交叉轴对齐方式*/&#125;.item:nth-child(3) &#123; align-self: flex-end;&#125; 5 四个方块在上一步的基础上再增加一个方块 5.1 1 2 3 9 位置 css:12345678910.box &#123; margin: 50px auto; height: 313px; width: 313px; border: 4px solid red; display: flex; flex-wrap: wrap; align-content: space-between; justify-content: flex-end;&#125; 5.2 四个角位置此种布局不能直接实现，我们需要进行分组，将横向的两个方块看做一组，在外层包裹一层div，来实现四个角位置的布局。 html:12345678910&lt;div class=\"box\"&gt; &lt;div class=\"column\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css:123456789101112131415.box &#123; margin: 50px auto; height: 313px; width: 313px; border: 4px solid red; display: flex; flex-wrap: wrap; align-content: space-between;&#125;.column &#123; display: flex; width: 100%; /*此处需要指定宽度，否则column内两个方块不能撑满整个容器*/ justify-content: space-between;&#125; 6 六个方块我们在上一步的基础上重新增加两个方块 6.1 1 2 3 7 8 9 位置 html:12345678&lt;div class=\"box\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; 123456789.box &#123; margin: 50px auto; height: 313px; width: 313px; border: 4px solid red; display: flex; flex-wrap: wrap; align-content: space-between;&#125; 6.2 1 3 4 6 7 9 位置 .box { margin: 50px auto; height: 313px; width: 313px; border: 4px solid red; display: flex; flex-direction: column; flex-wrap: wrap; align-content: space-between;} 6.3 1 2 3 5 7 9 位置 html:12345678910111213141516&lt;div class=\"box\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021.box &#123; margin: 50px auto; height: 313px; width: 313px; border: 4px solid red; display: flex; flex-wrap: wrap;&#125;.row &#123; display: flex; width: 100%; /*设定子容器的宽度很重要*/&#125;.row:nth-child(2) &#123; justify-content: center;&#125;.row:nth-child(3) &#123; justify-content: space-between;&#125; 7 九宫格 html:1234567891011&lt;div class=\"box\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678.box &#123; margin: 50px auto; height: 313px; width: 313px; border: 4px solid red; display: flex; flex-wrap: wrap;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://www.peihan.cc/categories/前端/"}],"tags":[]},{"title":"【ubuntu18.04折腾记】python开发环境搭建","slug":"article/2018/【ubuntu18.04折腾记】python开发环境搭建","date":"2018-07-21T02:28:51.000Z","updated":"2019-05-03T06:58:14.422Z","comments":true,"path":"2018/07/21/article/2018/【ubuntu18.04折腾记】python开发环境搭建/","link":"","permalink":"http://www.peihan.cc/2018/07/21/article/2018/【ubuntu18.04折腾记】python开发环境搭建/","excerpt":"0 背景自从将主力机器切换到ubuntu18.04后越发喜欢linux系统的简洁以及命令行的强大，除了玩三男一狗以及大菠萝3之外，基本都是在用这台机器。ubuntu18.04折腾记主要记录自己折腾ubuntu18.04的过程。","text":"0 背景自从将主力机器切换到ubuntu18.04后越发喜欢linux系统的简洁以及命令行的强大，除了玩三男一狗以及大菠萝3之外，基本都是在用这台机器。ubuntu18.04折腾记主要记录自己折腾ubuntu18.04的过程。 1 关于pythonubuntu18.04已经预装了python2.7和python3.6，我们无须再次安装python。 2 关于pipubuntu默认没有安装pip和pip3，所以我们需要手动安装pip和pip3利用ubuntu的apt-get包管理工具我们可以很方便的安装。 安装pip3 1sudo apt-get install python3-pip 安装pip 1sudo apt-get install python-pip 3 安装python虚拟环境python的第三方包真是不尽其数，如果我们能将第三方包安装到真实的python下则很容易造成冲突，所以使用python虚拟环境是一个不错的选择，方便进行环境的隔离和管理。 安装virtualenv接下来我们使用pip3来安装virtualenv 1sudo pip install virtualenv 我在这里踩了两个坑。 第一个坑是输入命令之后终端提示”Missing dependencies for SOCKS support” 原因是我本地开了socks代理…… 解决办法把代理先暂时关闭……2333333333 第二个坑是一开始执行pip install 没有加sudo，导致安装完成后执行virtualenv 提示no command，再次提醒一定要加sudo 创建虚拟环境首先我们来创建一个不带任何第三方包的纯净的python3开发环境 1mkdir -p py_env/py_3.6 1cd py_env/py_3.6 1virtualenv -p /usr/bin/python3 --no-site-packages venv -p 参数指示使用的解释器版本–no-site-packages 表示不使用系统中的包，即是完全纯净的环境–system-site-packages 是使用系统中的包 创建python2的环境同理，只需要修改-p参数 测试虚拟环境 启动虚拟环境 1source venv/bin/activate 当终端的开头多了(venv)之后可以证明当前已经是在虚拟环境中了 退出虚拟环境 1deactivate 4 安装pycharm工欲善其事必先利其器，安装好了python的虚拟运行环境后，我们再来安装pycharm。pycharm是我个人比较喜欢的python ide。在jetbrains官网下载*.tar.gz的压缩包。 解压缩 1tar -zxvf *.tar.gz 使用chmod a + x 给解压后的文件夹下bin目录的pycharm.sh增加可执行性权限 执行pycharm.sh即可以启动pycharm 为pycharm创建快捷方式 在/usr/share/applications下新建pycharm.desktop文件，写入以下内容： 12345678910[Desktop Entry]Encoding=UTF-8Name=pycharmComment=Pycharm IDEExec=/home/peihan/pycharm-2018.1.4/bin/pycharm.sh //替换为实际路径Icon=/home/peihan/pycharm-2018.1.4/bin/pycharm.png //替换为实际路径Terminal=falseStartupNotify=trueType=ApplicationCategories=Application;Development; 5 享受配置好以上之后，我们就可以使用python来愉快的开发了！","categories":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.peihan.cc/categories/ubuntu/"}],"tags":[]},{"title":"【RabbitMQ系列一】ubuntu安装rabbitmq","slug":"article/2018/【RabbitMq系列一】ubuntu安装rabbitmq","date":"2018-07-19T14:05:23.000Z","updated":"2019-05-03T06:57:40.064Z","comments":true,"path":"2018/07/19/article/2018/【RabbitMq系列一】ubuntu安装rabbitmq/","link":"","permalink":"http://www.peihan.cc/2018/07/19/article/2018/【RabbitMq系列一】ubuntu安装rabbitmq/","excerpt":"","text":"0 背景之前对于消息队列了解相对较少，这次想从头系统的学习下关于消息队列的相关内容，并记录下学习过程。 1 安装我使用的机器系统为ubuntu 18.04，本文的安装都是基于这个版本。 安装erlang由于rabbitmq的服务端是用erlang开发的，所以首先要安装erlang的运行环境。 1sudo apt-get install erlang-nox 安装Rabbitmq 12sudo apt-get updatesudo apt-get install rabbitmq-server 启动、停止、重启rabbitmq 123sudo rabbitmq-server startsudo rabbitmq-server stopsudo rabbitmq-server restart 2 可能会遇到的问题我在安装过程中遇到了两个问题，这里记录下问题以及解决方案。 安装完成后不能启动 终端报错信息为：“node with name “rabbit” already running on xxxx” rabbitmq安装完成后自动启动某些进程，导致使用rabbitmq-server 无法启动 解决方案： 查看rabbit相关的进程： 1ps aux | grep 'rabbit' kill掉与rabbit相关的进程： 1kill -9 [pid] 启动rabbitmq之后无法访问localhost:15672 从rabbitmq的启动日志可以看到rabbitmq在启动时加载了几个插件，如果是加载了0个插件，则无法访问rabbitmq的管理控制台，因为没有安装相关的Web插件。 解决方案：安装Web插件。 1sudo rabbitmq-plugins enable rabbitmq_management 之后打开浏览器输入 http://localhost:15672默认用户名密码：guest/guest，就可以看到管理界面了。 3 docker安装运行原生安装rabbitmq较为复杂，需要准备erlang的运行环境，使用docker可以大大减小复杂度。从dockerhub拉取我们需要的镜像，后缀带management是管理控制台的\bimgae，我们这里使用带管理控制台的镜像。 启动运行： 1docker run -d --hostname my-rabbit --name some-rabbit -p 15672:15672 -p 5672:5672 rabbitmq:3.7.7-management","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.peihan.cc/categories/中间件/"}],"tags":[]},{"title":"git代码回滚终极指南","slug":"article/2018/git代码回滚终极指南","date":"2018-07-16T12:34:58.000Z","updated":"2019-05-03T07:01:13.399Z","comments":true,"path":"2018/07/16/article/2018/git代码回滚终极指南/","link":"","permalink":"http://www.peihan.cc/2018/07/16/article/2018/git代码回滚终极指南/","excerpt":"git代码回滚终极指南0 背景git作为最受欢迎的版本控制工具，被很多开发者所喜欢。撤销回滚操作在git中是非常常用的操作。比如代码上线前需要删除掉其中的一个commit，排查线上代码需要临时增加一些log点，之后需要回退到之前的代码，针对不同的需求场景，需要使用不同的命令。\b本文从具体的实例出发，详细分析了不同的命令在不同场景下的用处。","text":"git代码回滚终极指南0 背景git作为最受欢迎的版本控制工具，被很多开发者所喜欢。撤销回滚操作在git中是非常常用的操作。比如代码上线前需要删除掉其中的一个commit，排查线上代码需要临时增加一些log点，之后需要回退到之前的代码，针对不同的需求场景，需要使用不同的命令。\b本文从具体的实例出发，详细分析了不同的命令在不同场景下的用处。 1 准备工作准备一个测试目录1mkdir git_exp git初始化1git init 准备测试内容为了使我们的例子更加的简单易懂，我在master分支添加一个a.txt文件，并且提交四次修改。分别增加字母abcd，此时文件内容为： 1234abcd git log如图： 推到远程仓库进行备份 关联远程仓库 1git add remote origin git@github.com:zhaipeihan/git_exp.git 推送到远程仓库 1git push origin master 2 git resetgit reset命令用于撤销commit，回退到某个版本上。 我们在之前master的基础上，创建reset_test分支进行测试 1git checkout -b reset_test \b我们现在的git log为： 1234d 75578cd7ae1a222c5fa745a0d2735a3448275a27c 076a714bed33fce4fa044b18b79f06f180ff3d97b d1e4634545ae8228556158734dc39e4783ec2d94a 739fe11e522ffca6c49061c9927e074d5ba3cbbd git reset命令常用参数有三个，影响程度从小到大为 –soft –mixed –hard我们依次使用这三个命令来恢复到 b这个commit上 –soft1git reset --soft d1e4634545ae8228556158734dc39e4783ec2d94 此时git log为： git status: 文件内容： –soft参数回退到版本b的提交状态上了，但是保留了之后修改文件内容，只是未提交的状态 –mixed我们使用之前的master分支来新建一个分支恢复到初始状态来测试–mixed 我们执行： 1git reset --mixed d1e4634545ae8228556158734dc39e4783ec2d94 执行之后的状态： –mixed\b参数同样恢复到版本b提交状态上了，也同样保留了之后修改的文件内容，与–soft不同的是，–mixed还没有提交到缓存区。 –hard我们使用之前的master分支来新建一个分支恢复到初始状态来测试–hard 我们执行： 1git reset --hard d1e4634545ae8228556158734dc39e4783ec2d94 执行之后的状态： –hard同样也恢复到了版本b的提交状态上了，但是–hard丢弃了工作区和缓存区的所有内容，所以之后修改的文件内容并没有保存，使用–hard需要慎重，确定不需要保留之后的修改内容之后再使用。 小节git reset 命令用来回退到某个版本上，其常用的–soft –mixed –hard三个参数对应了不同的修改场景，需要根据具体场景来选择。git reset是一个“危险的”操作，它可能会导致你永久的丢失提交记录。需要注意的是，本地仓库可以用reset来进行回退;如果\bcommit已经\bpush到自己的远程仓库，在reset回退之后，需要git push -f强制覆盖远程分支，否则\b因为缺少了后面的commit会造成冲突；如果是多人共享的公司远程仓库，建议不要使用reset进行回退版本，因为你回退了版本，会和别人的本地或者他人自己的远程仓库产生冲突，造成不必要的麻烦，如果需要回退共享仓库的版本应该使用下边分析的git revert。 3 git revertgit reset是直接删除了\b需要撤销的操作，这是比较危险的操作，git revert是在当前提交之后自动生成一个逆向的提交来\b达到回滚的效果。 我们在前面小节的基础上增加b.txt c.txt d.txt\b三个文件分别进行3次提交，现在的项目结构为： git log记录为： 接下来我们使用git revert来撤销add b file这个提交。 1git revert 3a1252d048bdd12cae8f1668584bc196428a1072 执行后的目录结构\b： 执行后的git log记录： 通过结果可以看到add b file这个操作已经被撤销，b\b.txt这个文件已经消失，并且commit历史中新增了一个commit。 git revert [commit1] [commit2] 可以撤销commit1到commit2之间的所有的提交 小结git revert命令是在当前的节点上向后生成了新的commit来撤销之前的操作，之前的commit并不会被删除，如果要撤销已经push到远程仓库的commit建议使用git revert,这是一个安全的操作，在后续的合并分支时不会产生冲突。 3 git rebasegit rebase用来重新编排所有的commit,此处可以用来撤销某个commit。我们此处还是以上一小节的例子来说明git rebase。 目前的\b项目结构和git log如上一小节执行git revert之后的状态所示。 此时我们进行一个撤销add c file的操作。 1git rebase -i 3a1252d048bdd12cae8f1668584bc196428a1072 注意使用git rebase 输入的commit版本号是想要撤销的commit的上一个commit号 执行该命令后，会出现一个类似交互式的界面，如图： 我们将想要删除的commit改为 drop 然后保存退出。 执行之后的目录结果为： add c file的操作已经被撤销，git log 如图： 我们可以看到 add c file的操作已经直接被撤销了，并且没有生成新的提交记录。 小结利用git rebase可以达到和git revert相同的效果，主要区别在于git rebase不会生成新的commit。 4 git checkout以上提到的都是提交层面的撤销操作，如果是想对未add到缓存区的内容做撤销操作，使用git checkout [filename] 如果已经add到缓存区，使用git checkout 并没有效果。此时可以使用git reset来回溯到上一个提交点。 5 总结以上我们分析了每一个命令对应的不同的撤销的场景，简单来说，改动未add到缓存区可以使用git checkout来放弃修改；已经提交commit，但是commit未push到远程仓库，可以使用reset来回到某个commit，如果是想删除某个特定的commit,可以使用rebase来操作；如果commit已经推送到远程仓库，建议使用git revert来撤销其中的操作。","categories":[],"tags":[]},{"title":"10分钟利用github + hexo搭建个人blog","slug":"article/2018/10分钟利用github-hexo搭建个人blog","date":"2018-07-10T05:48:10.000Z","updated":"2019-05-03T07:00:55.553Z","comments":true,"path":"2018/07/10/article/2018/10分钟利用github-hexo搭建个人blog/","link":"","permalink":"http://www.peihan.cc/2018/07/10/article/2018/10分钟利用github-hexo搭建个人blog/","excerpt":"本文主要记录使用hexo来搭建基于github的个人blog 0 准备工作 github账号 (github.com/zhaipeihan) 简单了解node.js npm 好奇的心","text":"本文主要记录使用hexo来搭建基于github的个人blog 0 准备工作 github账号 (github.com/zhaipeihan) 简单了解node.js npm 好奇的心 1 创建仓库在github上创建一个username.github.io的仓库（username为你自己的用户名） 2 hexo初始化 安装hexo 1npm install -g hexo-cli 初始化项目文件夹 1npm init 3 初步预览页面生成 1hexo g 本地预览（默认 localhost:4000/ ） 1hexo s 4 部署到github上项目的根目录下有_config.yml，这是hexo的主要配置文件，我们首先要将我们的github账户使用ssh方式配置上去，我的配置如下 1234deploy: type: git repo: git@github.com:zhaipeihan/zhaipeihan.github.io.git branch: master 先清理下，防止各种问题 1hexo clean 生成并上传 1hexo d -g 此处上传至github时可能报”ERROR Deployer not found: git”错误 解决方案如下： 1npm install hexo-deployer-git --save 等待生成页面上传之后就可以访问username.github.io来看到自己的博客了 5 使用主题主题爱好因人而异，我这里选择的是Archer（ github.com/fi3ework/hexo-theme-archer ） 接下来的配置过程都是基于\bArcher主题。主题安装方法见github说明。 6 其他配置接下来说明如何使用hexo的提供的分类和标签功能。 6.1 分类新建一个页面 1$hexo new page categories 根据生成的路径找到上一步生成的文件，修改其中的内容，内容如下： 12345---title: categoriesdate: 2018-07-12 13:28:40type: &quot;categories&quot;--- 以后在写文章的时候在文章顶部增加（注意格式）： 12categories:- 小玩意","categories":[{"name":"小玩意","slug":"小玩意","permalink":"http://www.peihan.cc/categories/小玩意/"}],"tags":[]}]}